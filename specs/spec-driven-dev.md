# Spec-Driven Development

## Overview

Spec-Driven Development (SDD) represents a fundamental shift in how we approach software development in the age of AI-powered coding agents. In this paradigm, **specifications are more important than code**. The spec becomes the code, and the actual code becomes the artifact—much like how compiled Java JARs are the output, not the source of truth.

### Core Philosophy

**Spec or specification is more important than code.**

This isn't hyperbole. Consider the impact:
- Bad code is bad code
- A bad implementation plan is 100 lines of bad code
- **A bad spec is thousands of lines of bad code**

When working with AI coding agents, your specification and implementation plan have exponential impact. Get the spec wrong, and you'll generate vast amounts of code headed in the wrong direction. Get it right, and you'll efficiently build exactly what you need.

**Specs should be checked into your repo and code reviewed.**

Your specifications deserve the same—if not more—scrutiny as your code. Review your specs. Iterate on them. Version control them. They are your most valuable artifact.

### The Paradigm Shift

In traditional development, developers write code directly. In Spec-Driven Development:

1. **Specifications drive everything** - They are precise, complete, and unambiguous enough to generate working systems
2. **Code is generated** - AI agents transform specs into implementation
3. **Iteration happens at the spec level** - When something needs to change, you update the spec and regenerate

This approach eliminates the gap between intent and implementation. Your specification becomes executable through AI agents, making the specification itself the primary development artifact.

### Spec-Driven vs. Vibe Coding

**Vibe coding** is the unstructured back-and-forth prompting with a coding agent:
- No clear phases or structure
- Context window becomes polluted with mixed concerns
- Doesn't scale beyond simple tasks
- Hard to reproduce or iterate
- Limited quality control

**Spec-Driven Development** is structured and scalable:
- Clear phases with specific objectives
- Context engineering keeps each phase focused
- Explicit validation and quality gates
- Reproducible through documented specs and plans
- Scales to complex, multi-phase projects

## Key Principles

### 1. Phase-Based Development

Break work into distinct phases, each with a clear purpose:
- **Research**: Understand the problem, codebase, and constraints
- **Planning**: Create detailed implementation plans
- **Implementation**: Execute the plan with validation

Each phase produces a markdown artifact that serves as input to the next phase.

### 2. Context Engineering

The reason for phased development is **context engineering**:

- **Limit your context window** - Each phase has a focused objective
- **Write context to disk** - Capture findings in markdown files
- **Clean slate for next phase** - The next session picks up from the artifact, not polluted context
- **Just enough context** - Give the agent exactly what it needs for the current job

This prevents context pollution and ensures each phase has optimal signal-to-noise ratio.

### 3. Validation & Quality Gates

**You want to give your coding agent signal to know if it's on the right track.**

Build validation into each phase:
- **Unit tests** - Does the code work as specified?
- **Type checking** - Are types consistent?
- **Build process** - Does it compile/build successfully?
- **Integration tests** - Do components work together?

For UI tasks:
- **Playwright MCP server** - Take screenshots, listen to browser console logs
- **Visual regression** - Compare UI states
- **Interaction testing** - Verify user flows

These quality gates give the coding agent immediate feedback, allowing it to course-correct before proceeding.

## Specs vs. Research & Plans

It's critical to understand the distinction between **specs** and **research/implementation plans**. They serve different purposes and are created by different authors.

### Specs (Human-Written)

**Specs are written by humans.** This is non-negotiable.

- **Location**: `specs/<feature-name>/mainspec.md`
- **Author**: You, the human developer
- **Purpose**: Define what you want built, with clarity and intent
- **Why human-written**: You need to know exactly what you're asking the AI to build. AI-generated specs can have massive downstream impacts—thousands of lines of code in the wrong direction.

Specs are your primary artifact. They represent your higher-level thinking about:
- What problem you're solving
- Why it matters
- What the solution should look like
- What constraints and patterns to follow

### Research & Implementation Plans (AI-Generated)

**Research and plans are generated by AI agents** during the phase workflow.

- **Location**: Working directory or project-specific locations
- **Examples**: `research.md`, `plan.md`, etc.
- **Author**: AI agents (via slash commands)
- **Purpose**: Explore the codebase and create actionable implementation steps based on your spec

These artifacts are important—they're how the AI organizes its understanding and approach. But they flow from your spec. They're downstream, not upstream.

### Both Are Important

- **Specs** define the feature you want built. 
- **Research** discovers the "how" based on your codebase
- **Plans** organize the "how" into actionable steps
- **Implementation** executes the plan

All are valuable. All should be version controlled. But only specs are human-authored.

## Spec Structure and Organization

### Folder Structure

Organize your specs by feature:

```
specs/
├── user-authentication/
│   ├── mainspec.md
│   └── slices/
│       ├── login-flow.md
│       └── password-reset.md
├── course-management/
│   ├── mainspec.md
│   └── slices/
│       ├── course-creation.md
│       └── course-enrollment.md
└── spec-driven-dev.md
```

**Key principles**:
- **One `mainspec.md` per feature** - This is your comprehensive specification for the entire feature
- **Logical slices in `/slices` folder** - Break the mainspec into smaller, focused specs in `specs/<feature-name>/slices/` that are easier for both you and the coding agent to reason about
- **Human-authored** - You write these, not AI

### Why Logical Slices?

**Start with the end in mind.** The mainspec.md is valuable because it defines your end state first, then you work backwards from there.

Once you have your mainspec, the logical slices become much easier to identify. You know where you're headed, and you can reverse-engineer the path to get there. This reverse engineering strategy—starting from the complete vision and decomposing it into manageable pieces—will become one of the key skills in a spec-driven world.

A large feature might be too complex to implement all at once. Logical slices let you:
- Work on one coherent piece at a time
- Give the coding agent focused context
- Make progress incrementally
- Reason about smaller, manageable chunks
- Track progress against the end state defined in mainspec.md

For example, "user authentication" might slice into:
- Login flow
- Registration flow
- Password reset
- Session management

Each slice gets its own spec file, but they all relate to the `mainspec.md`, which describes the complete end state you're working towards.

### Writing Good Specs

**This is now the abstraction level humans live in.** Not code. Higher-level thinking.

Your spec should be:
- **Clear and unambiguous** - The AI needs to understand your intent
- **Complete enough** - Cover the important details
- **Not overly prescriptive** - Don't pigeon-hole the AI or prevent it from finding good solutions

This is a balance that takes practice. Too vague, and the AI won't know what to build. Too specific, and you might confuse it or prevent better approaches.

### Recommended Spec Sections

There's no rigid template, but here are sections that work well:

- **Background** - Context about why this feature exists
- **User Story** - Who needs this and what they're trying to accomplish
- **Tech Details** - Technical requirements, constraints, or considerations
- **Architecture** - High-level architectural approach or components
- **UX/Design** - User experience expectations, flows, or design requirements
- **Special Callouts** - Important gotchas, edge cases, or considerations
- **Expected Patterns** - Code patterns, libraries, or approaches to use
- **Expected Deliverables** - What "done" looks like

Adapt these to your needs. The goal is clarity of intent, not adherence to a template.

### Example Spec Snippet

```markdown
# User Login Flow

## Background
Users need to authenticate before accessing course content. We're using JWT-based
authentication with refresh tokens.

## User Story
As a student, I want to log in with my email and password so I can access my courses.

## Tech Details
- Use bcrypt for password hashing
- JWT access tokens (15min expiry)
- Refresh tokens (7 day expiry)
- Store refresh tokens in httpOnly cookies

## Expected Patterns
- Follow existing auth patterns in `/backend/auth`
- Use the UserService for user lookups
- Validation with Zod schemas

## Expected Deliverables
- Login endpoint: POST /api/auth/login
- Refresh endpoint: POST /api/auth/refresh
- Unit tests for auth logic
- Integration tests for endpoints
```

This gives the AI clear direction while leaving room for good implementation decisions.

## Usage

This project implements Spec-Driven Development through a set of slash commands that represent the canonical workflow.

**The workflow starts with a human-written mainspec** (located in `specs/<feature-name>/mainspec.md`). Once you've defined your end state, you identify logical slices and create them in `specs/<feature-name>/slices/`. The phase commands then operate on individual slices to research, plan, and implement—keeping context focused.

While you can create specialized commands for specific task types (e.g., UI features), the underlying pattern remains the same.

### The Three-Phase Pattern

#### Phase 1: Research

**Command**: `.claude/commands/research`

**Purpose**: Deep exploration and analysis before writing any code.

**Input**: Your human-written spec (e.g., `specs/user-authentication/slices/login-flow.md`)

**What happens**:
- Reads your spec to understand what you want to build
- Uses subagents to explore and analyze your codebase
- Identifies existing patterns, components, and constraints
- Documents findings in a research artifact (markdown file)
- Answers critical questions: What exists? What's the architecture? What are the conventions?

**Output**: A research document (e.g., `research.md`) that becomes input to planning phase.

**Why it matters**: Research with AI agents can explore dozens of files and patterns that would take hours manually. You want this knowledge captured before planning.

#### Phase 2: Implementation Planning

**Command**: `.claude/commands/create_plan.md`

**Purpose**: Create a detailed, step-by-step implementation plan.

**Input**: Your spec + the research document from Phase 1

**What happens**:
- Reads your spec to understand the goal
- Reads the research document from Phase 1
- Generates a specific, actionable implementation plan
- Identifies dependencies and order of operations
- Specifies validation steps and quality gates
- Documents architectural decisions

**Output**: An implementation plan document (e.g., `plan.md`).

**Why it matters**: This is where you pay attention. A bad plan will generate 100s of lines of bad code. Review this plan carefully. Iterate on it. The plan is AI-generated, but it's derived from your human-written spec.

#### Phase 3: Implementation

**Command**: `.claude/commands/implement_plan.md`

**Purpose**: Execute the implementation plan with validation.

**Input**: The implementation plan from Phase 2

**What happens**:
- Reads the implementation plan from Phase 2
- Generates code following the plan step-by-step
- Runs validation gates (tests, type checking, builds)
- Self-corrects based on validation feedback
- Documents deviations or discoveries

**Output**: Working code that implements your specification.

**Why it matters**: With a solid plan (which flows from a solid spec), implementation becomes mechanical. The coding agent has clear direction and validation criteria.

### Specialized Workflows

While the three-phase pattern is universal, you can create specialized commands for specific contexts:

#### UI Development Example

```
.claude/commands/ui/research
.claude/commands/ui/create_plan_ui
.claude/commands/ui/implement_plan_ui
```

These might incorporate UI-specific concerns:
- Component library patterns
- Styling approaches
- Accessibility requirements
- Playwright validation

**The concept of phases remains the same**: Research → Plan → Implement, with context engineering and validation at each step.

### Iteration

**Iterate on your human-written specs first, then regenerate plans and code.**

If something isn't working:
1. Don't jump straight to code changes
2. Go back to the plan - is it still valid? Does it need regeneration?
3. Go back to the research - did we miss something? Does it need a re-run?
4. Go back to your spec - was it clear enough? Too vague? Too prescriptive?
5. Update your spec, then regenerate research/plan/implementation

This creates a virtuous cycle where your human-written specifications improve over time (through practice and iteration), and your codebase stays aligned with intent.

**Remember**: The spec is human-written and version-controlled. Plans and research are AI-generated artifacts. Both are valuable, but the spec is upstream—it drives everything else.

## Best Practices

### 1. Start with the Spec (Human-Written)

Before opening a coding agent session, **you write the spec**:
- What you're trying to achieve
- Why it's needed
- What success looks like
- What constraints exist

Start by creating `specs/<feature-name>/mainspec.md` to define your end state. Then reverse-engineer logical slices from it and place them in `specs/<feature-name>/slices/`. These human-written specs drive everything else.

### 2. Review Your Specs, Then Review Plans

**Your human-written spec is the most important artifact.** Get it right before running the phase commands.

AI-generated implementation plans also deserve scrutiny. If the plan is solid and validation gates pass, you will have an easier time trusting the generated code. If validation fails, check if:
- The plan needs refinement (regenerate Phase 2)
- Your spec was unclear (update your spec and rerun from Phase 1)

### 3. Validate Continuously

Don't wait until the end. Run tests, type checking, and builds throughout implementation. Each piece of feedback helps the agent stay on track. This should be embedded in your slash commands (the 3 phases)

### 4. Document Learnings

When implementation reveals gaps in the plan or research, document them. These learnings improve future specs.

### 5. Version Control Everything

**Specs (human-written) are mandatory to version control.** They're your primary artifact.

Research documents and implementation plans (AI-generated) are also valuable to check in—they provide context and can be reused or referenced. But the spec is the source of truth.

## Conclusion

Spec-Driven Development recognizes that in the age of AI coding agents, the bottleneck isn't writing code—it's knowing what to write. By elevating human-written specifications to first-class artifacts and organizing work into focused, validated phases, we can build better software faster.

**This is your new abstraction level.** Not code—higher-level thinking. Writing clear, complete, unambiguous specs that guide AI agents to build what you envision.

The spec is the code. The code is the artifact. Everything flows from your specification.

Start with a good spec. The rest follows.
